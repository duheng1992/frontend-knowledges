## 1. 原型链关系图

原型的概念借鉴了 Self 语言
<img src="../images/原型链关系图.jpg" />

## 2. 实现一个访问器 (类似 es6 里的 get totalPrice() {})

```js
function Product(price, number) {
  this.price = price;
  this.number = number;
}

Object.defineProperty(Product.prototype, 'totalPrice', {
  get() {
    return this.price * this.number;
  }
})

// 访问
const p = new Product(100, 5);
p.totalPrice
```

## 3. 常用 Object 静态方法 与作用

| 静态方法                 | 作用                                                                                                         | 返回值                                                         | 备注                                                                         |
| :----------------------- | :----------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------- | :--------------------------------------------------------------------------- |
| `Object.keys(obj)`       | 返回一个由给定对象自身可枚举属性的键（属性名）组成的数组。                                                 | 字符串数组                                                       | 不包括原型链上的属性和不可枚举的属性。                                       |
| `Object.values(obj)`     | 返回一个由给定对象自身可枚举属性的值组成的数组。                                                           | 任意类型值的数组                                                 | 不包括原型链上的属性和不可枚举的属性。                                       |
| `Object.entries(obj)`    | 返回一个由给定对象自身可枚举属性的键值对组成的数组。每个键值对是一个包含 `[key, value]` 的数组。           | `[key, value]` 对的数组                                          | 不包括原型链上的属性和不可枚举的属性。                                       |
| `Object.assign(target, ...sources)` | 将所有可枚举的自有属性从一个或多个源对象复制到目标对象。它会修改并返回目标对象。             | 修改后的目标对象                                                 | 浅拷贝（只复制属性值，如果属性值是引用类型，则复制引用）。                     |
| `Object.freeze(obj)`     | 冻结一个对象。一个被冻结的对象再也不能被修改；冻结操作阻止了对对象添加新属性、删除已有属性、修改该对象已有属性的可枚举性、可配置性、可写性，以及修改已有属性的值。它也阻止了原型链的修改。 | 被冻结的对象                                                     | 返回与传入对象相同的对象。冻结是浅层的。                                     |
| `Object.seal(obj)`       | 封闭一个对象。密封一个对象会阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值仍然可以更改。       | 被密封的对象                                                     | 返回与传入对象相同的对象。密封是浅层的。                                     |
| `Object.preventExtensions(obj)` | 阻止新属性被添加到对象。现有属性可以被修改或删除。                                           | 被修改的对象                                                     | 这是三种“不变性”方法中最宽松的。                                             |
| `Object.isFrozen(obj)`   | 判断一个对象是否被冻结。                                                                                     | 布尔值 (`true` 或 `false`)                                       |                                                                              |
| `Object.isSealed(obj)`   | 判断一个对象是否被密封。                                                                                     | 布尔值 (`true` 或 `false`)                                       |                                                                              |
| `Object.isExtensible(obj)` | 判断一个对象是否是可扩展的（即是否可以添加新属性）。                                                       | 布尔值 (`true` 或 `false`)                                       |                                                                              |
| `Object.create(proto, [propertiesObject])` | 使用指定的原型对象和属性创建一个新对象。                                                     | 一个新对象                                                       | 常用于实现继承。                                                             |
| `Object.defineProperty(obj, prop, descriptor)` | 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回该对象。                   | 被修改的对象                                                     | 允许精细控制属性的特性（如 `value`, `writable`, `enumerable`, `configurable`）。 |
| `Object.defineProperties(obj, props)` | 在一个对象上定义或修改多个属性，并返回该对象。                                             | 被修改的对象                                                     | 类似于 `Object.defineProperty` 的批量版本。                                  |
| `Object.getOwnPropertyDescriptor(obj, prop)` | 返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接在对象上定义的属性，而不是从原型链上继承的属性）。 | 属性描述符对象或 `undefined`                                     | 属性描述符包括 `value`, `writable`, `get`, `set`, `configurable`, `enumerable`。 |
| `Object.getOwnPropertyDescriptors(obj)` | 返回一个对象，该对象的所有自身属性的描述符。                                               | 属性描述符对象                                                   | 返回给定对象所有自有属性的描述符，包括不可枚举的。                               |
| `Object.getPrototypeOf(obj)` | 返回指定对象的原型（即内部的 `[[Prototype]]`）。                                             | 对象的原型，或者 `null`                                          | 用于获取对象的原型链上的上一级对象。                                         |
| `Object.setPrototypeOf(obj, prototype)` | 设置一个对象的原型（即内部的 `[[Prototype]]`）。                                             | 被修改的对象                                                     | **不推荐在生产代码中使用**，因为它对性能有显著影响。应优先使用 `Object.create()`。 |
| `Object.is(value1, value2)` | 判断两个值是否是同一个值。比 `===` 更严格地处理 `+0` 和 `-0`，以及 `NaN`。                     | 布尔值 (`true` 或 `false`)                                       | `Object.is(NaN, NaN)` 返回 `true`，而 `NaN === NaN` 返回 `false`。\<br\>`Object.is(+0, -0)` 返回 `false`，而 `+0 === -0` 返回 `true`。 |

-----

## 4. 下面输出什么

```js
Object.prototype.__proto__    //null
Function.prototype.__proto__  //Object.prototype

// Object 也是一个构造函数
Object.__proto__              //Function.prototype
Object.__proto__.__proto__ === Object.prototype // true

typeof `${{Object}}`.__proto__ // 'object'
typeof `${{Object}}`.prototype // 'undefined'
```

> 引申：字符串字面量的 `__proto__`，相当于找构造函数 String.prototype 

> 当你写 'hello'.toUpperCase() 时，虽然 'hello' 是一个基本类型，JavaScript 引擎会临时将其“包装”成一个 String 对象，这个临时对象会通过其原型链找到 String.prototype 上的 toUpperCase 方法并调用它。


## 5. 按要求写代码

按照如下要求实现Person 和 Student 对象
 - a) Student 继承Person 
 - b) Person 包含一个实例变量 name， 包含一个方法 say
 - c) Student 包含一个实例变量 score， 包含一个实例方法printScore
 - d) 所有Person和Student对象之间共享一个方法

```js
// 定义Person类
class Person {
  constructor(name) {
    this.name = name; // 实例变量name
  }

  // 实例方法say
  say() {
    console.log(this.name);
  }

  // 所有对象共享的方法（定义在Person原型上）
  commonMethod() {
    console.log('这是Person和Student共享的方法');
  }
}

// Student类继承Person
class Student extends Person {
  constructor(name, score) {
    super(name); // 调用父类构造函数
    this.score = score; // 实例变量score
  }

  // 实例方法printScore
  printScore() {
    console.log(this.score);
  }
}
```

function 实现：

```js
// 定义Person构造函数
function Person(name) {
  this.name = name; // 实例变量name
  this.say = function() {
    console.log(this.name);
  };
}

// 定义共享方法（所有实例共享）
Person.prototype.commonMethod = function() {
  console.log('这是Person和Student共享的方法');
};

// 定义Student构造函数
function Student(name, score) {
  // 调用Person构造函数实现属性继承
  Person.call(this, name);
  this.score = score; // 实例变量score
  this.printScore = function() {
    console.log(this.score);
  };
}

// 实现原型链继承，浅拷贝
Student.prototype = Object.create(Person.prototype);
// 修复继承的原型链的构造函数指向
Student.prototype.constructor = Student;
```

## 6. 进阶：Person.prototype.say 定义以后，所有 Person 定义出来的实例都有 say 这个方法了，如何只让个别 new 出来的 Person 有这个 say方法？

```js
// 方式1
const person1 = new Person('Alice');
person1.say = function() {
  console.log(`Hello, my name is ${this.name}`);
};
// 方式2 工厂函数
function createPerson(name, canSay = false) {
  const person = new Person(name);
  if (canSay) {
    person.say = function() {
      console.log(`Hello, my name is ${this.name}`);
    };
  }
  return person;
}
// 方式3 定义新的类继承一下
function Person(name) {
  this.name = name;
}

function TalkativePerson(name) {
  Person.call(this, name); // 继承 Person 的属性
}

TalkativePerson.prototype.say = function() {
  console.log(`Hello, my name is ${this.name}`);
};
// 方式4  代理
const handler = {
  get: function(target, property, receiver) {
    if (property === 'say' && target.hasSay) {
      return function() {
        console.log(`Hello, my name is ${target.name}`);
      };
    }
    return Reflect.get(...arguments);
  }
};
function Person(name, hasSay = false) {
  this.name = name;
  this.hasSay = hasSay; // 标记是否拥有 say 方法
}

const person1 = new Person('Alice', true);
const person1Proxy = new Proxy(person1, handler);
person1Proxy.say(); // 正常工作
```

## 7. `__proto__` 属性和 prototype 属性的差别是什么?

> `__proto__` 和 `prototype` 是不同的属性。 `__proto__` 是每个物件的一个隐藏属性，每个物件可以由 `__proto__` 访问到它的原型。而 `prototype` 是存在于所有构造函式中的一个属性，构造函式的 `prototype` 其实和 `__proto__` 会指向同一个地方的，这个地方就叫做原型对象。

## 8. 构造函数与普通函数区别

- 1、构造函数也是一个普通函数，创建方式和普通函数一样，但构造函数习惯上首字母大写。
- 2、调用方式不一样。
普通函数的调用方式：直接调用 person();
构造函数的调用方式：需要使用new关键字来调用 new Person();
- 3、构造函数的函数名与类名相同：Person( ) 这个构造函数，Person 既是函数名，也是这个对象的类名。(ES6 中 class 与构造函数的关 系,通过class定义的类 和通过构造函数定义的类 二者本质相同。并且在js执行时，会将第一种转会为第二种执行。所以 ES6 class的写法实质就是构造函数)
- 4、内部用this 来构造属性和方法
- 5、构造函数的执行流程
    - A、立刻在堆内存中创建一个新的对象
    - B、将新建的对象设置为函数中的this
    - C、逐个执行函数中的代码
    - D、将新建的对象作为返回值
- 6、构造函数的返回值默认是this 也有其他情况。普通函数：默认为undefined

## 9. 输出什么

```js
// 1
function f(){ return f; }
new f() instanceof f;  // new f() 的结果就是 f 本身, instanceof 的作用是检查右侧构造函数的 prototype 是否在左侧对象的原型链上。这里实际执行的是：f instanceof f, 函数 f 的原型链是：f -> Function.prototype -> Object.prototype。

// 2
(function(){
  let f = this ? class g {} : class h {}; // 在非严格模式下，this 的值取决于执行环境 
  return [
    typeof f,
    typeof h
  ]
})()

// 3
(typeof (new (class { class() {} }))) // 匿名类 class { class() {} }

// 4
typeof (new (class F extends (String, Array) {})).substring

// 5 计算属性 [f]
typeof (new class f { [f]() {}; f = {}; })[`${f}`];
```

## 10. function 继承的几种方式

声明：

```js
function SuperType() {
    this.property = true;
}

function SubType() {
    this.subproperty = false;
}
```

#### (1) 原型链继承

```js
SubType.prototype = new SuperType(); 
```
缺点：多个子类实例对引用类型的操作会被篡改（共享实例属性）；父类构造函数被调用。

#### (2) 构造函数继承

```js
function  SubType(){
    //继承自SuperType
    SuperType.call(this);
}
```
缺点：

- 只能继承父类的实例属性和方法，不能继承原型属性/方法
- 无法实现复用，每个子类都有父类实例函数的副本，影响性能

#### (3) 组合继承

```js
function  SubType(){
    //继承自SuperType
    SuperType.call(this);
}
SubType.prototype = Object.create(SuperType.prototype); // 改进的原型链，更灵活，避免共享实例属性问题
```
缺点: 在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。

#### (4) 原型继承

```js
function object(obj){
  function F(){}
  F.prototype = obj;
  return new F();
}
```

缺点：

- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
- 无法传递参数


#### (5) 副本寄生继承

```js
function createAnother(original) {
    let clone = Object.create(original); // 类似原型继承
    clone.say = function() {             // 以某种方式增强这个对象
        console.log("hello");
    };
    return clone; // 返回这个对象
}
```
缺点：

- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
- 无法传递参数

#### (6) 寄生组合式继承

```js
function  SubType(){
    //继承自SuperType
    SuperType.call(this);
}
SubType.prototype = Object.create(SuperType.prototype); // 改进的原型链，更灵活，避免共享实例属性问题
SubType.prototype.constructor = SubType; 
```

## 11. 如何在ES5和ES6中实现类的私有变量？

```js
// ES6方式(Symbol)
const _name = Symbol('name');
class Person {
  constructor(name) {
    this[_name] = name;
  }
  getName() { return this[_name]; }
}

// ES2022方式(#语法)
class Person {
  #name; // 私有字段
  constructor(name) {
    this.#name = name;
  }
  getName() { return this.#name; }
}
```

## 12. 如何用模块模式实现一个计数器，保证计数变量不被外部直接访问？

```js
const counter = (function() {
  let count = 0;
  
  return {
    increment() { count++; },
    decrement() { count--; },
    getCount() { return count; }
  };
})();
```

## 13. 用JavaScript实现动物世界的多态，有Dog和Cat类，都继承自Animal类，但各自有不同的sound方法。

```js
class Animal {
  makeSound() {
    throw new Error('此方法必须由子类实现');
  }
}

class Dog extends Animal {
  makeSound() {
    return '汪汪汪';
  }
}

class Cat extends Animal {
  makeSound() {
    return '喵喵喵';
  }
}

function animalSound(animal) {
  console.log(animal.makeSound());
}

const dog = new Dog();
const cat = new Cat();

animalSound(dog); // 汪汪汪
animalSound(cat); // 喵喵喵
```

## 14. 什么是鸭子类型？如何在JavaScript中利用鸭子类型实现多态？

鸭子类型：如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子

```js
class Duck {
  quack() { console.log('嘎嘎嘎'); }
  swim() { console.log('游泳'); }
}

class Person {
  quack() { console.log('人类模仿鸭子叫'); }
  swim() { console.log('人类游泳'); }
}

function doDuckThings(duck) {
  duck.quack();
  duck.swim();
}
```

## 15. 用封装和多态的思想实现一个状态机(State Machine)，支持状态切换和不同状态下的不同行为。

```js
class State {
  constructor(stateMachine) {
    this.stateMachine = stateMachine;
  }
  
  enter() {}
  exit() {}
  update() {}
}

class IdleState extends State {
  enter() { console.log('进入空闲状态'); }
  update() { console.log('当前是空闲状态'); }
  exit() { console.log('退出空闲状态'); }
}

class MovingState extends State {
  enter() { console.log('进入移动状态'); }
  update() { console.log('当前是移动状态'); }
  exit() { console.log('退出移动状态'); }
}

class StateMachine {
  constructor() {
    this.states = {
      idle: new IdleState(this),
      moving: new MovingState(this)
    };
    this.currentState = null;
  }
  
  changeState(stateName) {
    if (this.currentState) {
      this.currentState.exit();
    }
    
    this.currentState = this.states[stateName];
    this.currentState.enter();
  }
  
  update() {
    if (this.currentState) {
      this.currentState.update();
    }
  }
}
```

## 16. 设计一个支付系统，支持多种支付方式(支付宝、微信、银行卡)，方便后续扩展新的支付方式。

```js
abstract class PaymentStrategy {
  abstract pay(amount);
}

class AlipayStrategy extends PaymentStrategy {
  pay(amount) {
    console.log(`使用支付宝支付 ${amount} 元`);
    // 实际的支付宝支付逻辑
  }
}

class WechatPayStrategy extends PaymentStrategy {
  pay(amount) {
    console.log(`使用微信支付 ${amount} 元`);
    // 实际的微信支付逻辑
  }
}

class PaymentContext {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  executePayment(amount) {
    return this.strategy.pay(amount);
  }
}
```

## 17. 实现一个深层次不可变对象

```js
function deepFreeze(obj) {
  Object.freeze(obj); // 他是浅冻结
  Object.keys(obj).forEach(key => {
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      deepFreeze(obj[key]);
    }
  });
  return obj;
}
```

## 18. 实现依赖注入

依赖注入(Dependency Injection, DI) 是一种实现控制反转(IoC)的设计模式，它的核心思想是：将类所依赖的其他对象的创建和绑定转移到类的外部去管理，而不是在类内部直接创建依赖对象。

```js
class DIContainer {
  constructor() {
    this.services = {};
  }
  
  register(name, service) {
    // service 的创建交给外部
    this.services[name] = service;
  }
  
  inject(dependencies, callback) {
    const resolved = dependencies.map(name => {
      if (!this.services[name]) {
        throw new Error(`未找到服务: ${name}`);
      }
      return this.services[name];
    });
    return callback(...resolved);
  }
}

// 使用示例
const di = new DIContainer();
di.register('logger', { log: msg => console.log(msg) });
di.register('api', { fetch: () => '数据' });

di.inject(['logger', 'api'], (logger, api) => {
  logger.log(api.fetch()); // 输出: "数据"
});
```