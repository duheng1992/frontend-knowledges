## 1. 如何创建并触发一个自定义事件？

```js
// 创建自定义事件
const event = new CustomEvent('myEvent', {
  detail: { message: '自定义数据' },
  bubbles: true,
  cancelable: true
});

// 监听事件
element.addEventListener('myEvent', (e) => {
  console.log(e.detail.message);
});

// 触发事件
element.dispatchEvent(event);
```

## 2. 事件循环原理

https://juejin.cn/post/7288956366515929088

## 3. 下面输出什么

```js
// 1
button.addEventListener('click', () => {
  Promise.resolve().then(() => console.log('Microtask 1'));
  console.log('Listener 1');
});
button.addEventListener('click', () => {
  Promise.resolve().then(() => console.log('Microtask 2'));
  console.log('Listener 2');
});
button.click(); // 程序触发 vs 用户点击输出顺序有何不同？

// Listener 1  Listener 2  Microtask 1  Microtask 2

// 2
const obj = {
  name: 'obj',
  handleClick() {
    console.log(this); // 输出什么？
    setTimeout(function() {
      console.log(this.name); // 输出什么？
    }, 100);
  }
};
button.addEventListener('click', obj.handleClick);

// ''
// 解释：事件回调的this 默认指向 currentTarget，即注册事件的那个元素，这里是 button；setTimeout 里边的 this 这里指向了 Window （非严格模式）
// 要想实现输出 obj
const obj = {
  name: 'obj',
  handleClick() {
    console.log(this); // obj{}
    const that = this;
    setTimeout(function() { // 或者这里用箭头函数也可
      console.log(that.name); // obj
    }, 100);
  }
};
button.addEventListener('click', obj.handleClick.bind(obj))
```

## 4. e.target vs e.currentTarget 区别

```js
// 如何用事件代理实现动态列表的点击监听？
document.getElementById('list').addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') {
    // 这里不能用 currentTarget，而要用 target
    console.log(e.target.dataset.id);
  }
});
```

## 5. addEventListener 的第三个参数是什么？做什么用的？

可以是一个布尔值，也可以是一个对象。

- 布尔值，默认是 capture 属性 （true：事件监听器会在捕获阶段触发（从 document 到目标元素）；false：事件监听器会在冒泡阶段触发（从目标元素到 document）。这是默认行为。）
- 对象 （capture、once 事件监听器在触发一次后会自动移除、passive 浏览器可以进行优化，减少事件处理的延迟、signal 动态移除事件监听器）

## 5.1 捕获阶段触发还是冒泡阶段触发有什么实际的作用？

- 捕获阶段触发：

事件在捕获阶段触发，适用于提前处理事件、避免冲突和性能优化。
使用 capture: true 在 addEventListener 中设置。

- 冒泡阶段触发：

事件在冒泡阶段触发，适用于常见的事件处理、动态处理和阻止默认行为。
使用 capture: false（默认值）在 addEventListener 中设置。


例子：事件捕获阻止子元素获取事件

```js
const parent = document.getElementById('parent');
const child = document.getElementById('child');

// 捕获阶段阻止事件
parent.addEventListener('click', (event) => {
  console.log('Parent (Capturing Phase)');
  event.stopPropagation(); // 阻止事件进一步传播（向上或向下）
}, { capture: true });

child.addEventListener('click', () => {
  // 这里拿不到事件
  console.log('Child (Bubbling Phase)');
});
```

## 6. 实现防抖节流函数: 面试常要求手写实现

参考：

```js
function debounce(func, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer);    
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay)
  }
}
```

```js
const throttle = (fn, wait = 50) => {
  let previous = 0;
  return function(...args) {
    let now = +new Date()
    if (now - previous > wait) {
      previous = now
      fn.apply(this, args)
    }
  }
}
```

## 6.1 防抖节流的使用场景有什么区别

## 7. event.preventDefault() 与 return false 的区别

```js
form.addEventListener('submit', (e) => {
  e.preventDefault(); // 阻止默认行为
  return false;      // 还额外阻止事件冒泡（jQuery风格）
});
```

## 8. passive 选项避免滚动卡顿的底层原理？无法与 preventDefault 共用的原因

## 9. React 合成事件机制 vs 原生事件

## 10. AbortController 实现监听移除

```js
const controller = new AbortController();
button.addEventListener('click', handler, { 
  signal: controller.signal 
});
controller.abort(); // 移除监听
```