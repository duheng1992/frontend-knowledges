1. 实现 `Promise.all`（需处理错误边界）

```js
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    // 如果输入不是数组，可以转换为数组或直接reject
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }

    const results = [];
    let completedCount = 0;
    const totalPromises = promises.length;

    // 处理空数组情况
    if (totalPromises === 0) {
      return resolve(results);
    }

    promises.forEach((promise, index) => {
      // 确保处理的是Promise对象（处理非Promise值）
      Promise.resolve(promise)
        .then((value) => {
          results[index] = value;
          completedCount++;
          
          // 当所有Promise都完成时，resolve结果
          if (completedCount === totalPromises) {
            resolve(results);
          }
        })
        .catch(reject); // 任何一个Promise reject，整体就reject
    });
  });
}
```

2. 实现 `Promise.race`（需处理错误边界）

```js
function promiseRace(promises) {
  return new Promise((resolve, reject) => {
    // 参数验证
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }

    // 处理空数组情况（根据规范，空数组会永久挂起）
    if (promises.length === 0) {
      return; // 不调用resolve或reject，Promise将永远pending
    }

    promises.forEach(promise => {
      // 确保处理的是Promise对象（处理非Promise值）
      Promise.resolve(promise)
        .then(resolve) // 第一个resolve触发外层resolve
        .catch(reject); // 第一个reject触发外层reject
    });
  });
}
```

3. 实现 `Promise.any`（需处理错误边界）

```js
function promiseAny(promises) {
  return new Promise((resolve, reject) => {
    // 参数验证
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Argument must be an array'));
    }

    // 处理空数组情况
    if (promises.length === 0) {
      return reject(new AggregateError([], 'All promises were rejected'));
    }

    const errors = [];
    let rejectedCount = 0;

    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(resolve) // 任何一个resolve就立即解决外层Promise
        .catch(error => {
          errors[index] = error;
          rejectedCount++;
          
          // 当所有Promise都被拒绝时
          if (rejectedCount === promises.length) {
            reject(new AggregateError(
              errors, 
              'All promises were rejected'
            ));
          }
        });
    });
  });
}
```

4. 防抖（`debounce`）与节流（`throttle`）的实现及适用场景  

>监听 input 事件，使用 AbortController 也可以实现防抖
```js
// 1. debounce: 表单输入和验证场景、resize、点击动作 等只关注最终状态的场景
input.addEventListener('input', () => {
  controller.abort();
  setTimeout(() => {
    // 执行操作
  }, 500);
}, { signal: controller.signal });

// 2. debounce
function debounce(func, delay) {
  let timer = null;
  
  return function(...args) {
    const context = this;
    
    // 清除之前的定时器
    if (timer) clearTimeout(timer);
    
    // 设置新的定时器
    timer = setTimeout(() => {
      timer = null;
      func.apply(context, args);
    }, delay);
  };
}

// 3. throttle：在一定时间间隔内，函数最多执行一次，适合关注过程状态的场景。滚动事件、鼠标移动等
function throttle(func, delay, options = {}) {
  let timer = null;
  let lastTime = 0;
  const { leading = true, trailing = true } = options;
  
  return function(...args) {
    const context = this;
    const now = Date.now();
    
    // 首次不立即执行（leading为false时）
    if (!leading && !lastTime) {
      lastTime = now;
    }
    
    const remaining = delay - (now - lastTime);
    
    if (remaining <= 0 || remaining > delay) {
      // 清除定时器
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      
      lastTime = now;
      func.apply(context, args);
    } else if (trailing && !timer) {
      // 设置定时器，确保最后一次会执行
      timer = setTimeout(() => {
        lastTime = leading ? Date.now() : 0;
        timer = null;
        func.apply(context, args);
      }, remaining);
    }
  };
}
```

5. 原型链关系图

原型的概念借鉴了 Self 语言
<img src="../images/原型链关系图.jpg" />

6. 组合寄生继承

```js
function  SubType(){
  //继承自SuperType
  SuperType.call(this);
}
SubType.prototype = Object.create(SuperType.prototype); // 改进的原型链，更灵活，避免共享实例属性问题
SubType.prototype.constructor = SubType; 
```
7. 深拷贝

```js
function deepClone(target, map = new WeakMap()) {
  // 处理原始类型
  if (target === null || typeof target !== 'object') {
    return target;
  }

  // 处理特殊对象类型
  if (target instanceof Date) return new Date(target);
  if (target instanceof RegExp) return new RegExp(target);
  if (target instanceof Map) return new Map(Array.from(target.entries()));
  if (target instanceof Set) return new Set(Array.from(target.values()));

  // 检查循环引用
  if (map.has(target)) {
    return map.get(target);
  }

  // 初始化克隆对象
  const proto = Object.getPrototypeOf(target);
  const cloneObj = Object.create(proto);
  // 缓存当前对象，防止循环引用
  map.set(target, cloneObj);

  // 克隆Symbol属性
  const symKeys = Object.getOwnPropertySymbols(target);
  for (const symKey of symKeys) {
    clone[symKey] = deepClone(target[symKey], map);
  }

  // 克隆常规属性
  for (const key in target) {
    if (Object.prototype.hasOwnProperty.call(target, key)) {
      clone[key] = deepClone(target[key], map);
    }
  }

  return clone;
}
```

8. Event loop

https://juejin.cn/post/7288956366515929088

https://juejin.cn/post/7293820517375623168

9. `Proxy` 和 `Reflect`

# Proxy 和 Reflect 大厂面试题解析

## 一、核心概念理解

### 1. Proxy 是什么？
Proxy 是 ES6 引入的用于创建对象代理的构造函数，可以拦截并自定义对象的基本操作（如属性查找、赋值、枚举等）。

**基本语法**：
```javascript
const proxy = new Proxy(target, handler)
```
- `target`：要代理的目标对象
- `handler`：包含拦截器（traps）的对象

### 2. Reflect 是什么？
Reflect 是 ES6 提供的操作对象的 API，它提供了一组与 Proxy handlers 对应的方法，用于更优雅地操作对象。

**设计目的**：
- 将 Object 的一些明显属于语言内部的方法（如 `Object.defineProperty`）转移到 Reflect 上
- 修改某些 Object 方法的返回结果（如 `Object.defineProperty` 失败时返回 false 而不是抛出错误）
- 让 Object 操作都变成函数行为

## 二、常见面试题

### 1. 实现一个属性访问追踪器
**题目**：使用 Proxy 实现一个对象，当访问或设置其属性时能打印日志

**解答**：
```javascript
const createTrackableObject = (obj) => {
  return new Proxy(obj, {
    get(target, prop) {
      console.log(`Getting ${prop}`);
      return Reflect.get(target, prop);
    },
    set(target, prop, value) {
      console.log(`Setting ${prop} to ${value}`);
      return Reflect.set(target, prop, value);
    }
  });
};

const obj = createTrackableObject({ a: 1 });
obj.a; // 控制台输出: Getting a
obj.b = 2; // 控制台输出: Setting b to 2
```

### 2. 实现数组负索引访问
**题目**：使用 Proxy 使数组支持负索引（如 `arr[-1]` 访问最后一个元素）

**解答**：
```javascript
const createNegativeArray = (arr) => {
  return new Proxy(arr, {
    get(target, prop) {
      const index = parseInt(prop);
      if (index < 0) {
        prop = target.length + index;
      }
      return Reflect.get(target, prop);
    }
  });
};

const arr = createNegativeArray([1, 2, 3]);
console.log(arr[-1]); // 3
console.log(arr[-2]); // 2
```

### 3. 实现数据验证
**题目**：使用 Proxy 实现对象属性赋值时的类型检查

**解答**：
```javascript
const createValidatedObject = (obj, schema) => {
  return new Proxy(obj, {
    set(target, prop, value) {
      if (schema[prop] && typeof value !== schema[prop]) {
        throw new TypeError(`Expected ${prop} to be ${schema[prop]}`);
      }
      return Reflect.set(target, prop, value);
    }
  });
};

const person = createValidatedObject({}, {
  name: 'string',
  age: 'number'
});

person.name = 'Alice'; // OK
person.age = '30'; // TypeError: Expected age to be number
```

### 4. 实现自动填充对象
**题目**：使用 Proxy 实现对象访问不存在的属性时返回默认值而不是 undefined

**解答**：
```javascript
const createDefaultingObject = (defaultValue) => {
  return new Proxy({}, {
    get(target, prop) {
      if (!(prop in target)) {
        target[prop] = defaultValue;
      }
      return Reflect.get(target, prop);
    }
  });
};

const obj = createDefaultingObject(0);
console.log(obj.a); // 0
console.log(obj.b); // 0
```

### 5. Proxy 和 Reflect 的关系
**问题**：为什么 Proxy 的 handler 方法通常与 Reflect 方法配合使用？

**答案**：
1. **保持默认行为**：Reflect 提供了与 Proxy traps 对应的原始对象操作
2. **避免重复实现**：直接调用 Reflect 方法比手动实现默认行为更可靠
3. **一致性**：Reflect 方法的参数与 Proxy traps 完全匹配
4. **返回值处理**：Reflect 方法返回布尔值表示操作是否成功，便于 Proxy 处理

## 三、高级应用场景

### 1. 实现观察者模式
```javascript
const createObservable = (obj, callback) => {
  return new Proxy(obj, {
    set(target, prop, value) {
      const oldValue = target[prop];
      const result = Reflect.set(target, prop, value);
      if (oldValue !== value) {
        callback(prop, oldValue, value);
      }
      return result;
    }
  });
};

const user = createObservable({ name: 'Alice' }, (key, oldVal, newVal) => {
  console.log(`${key} changed from ${oldVal} to ${newVal}`);
});

user.name = 'Bob'; // 控制台输出: name changed from Alice to Bob
```

### 2. 实现私有属性
```javascript
const createPrivatePropsObject = (obj, privateProps = []) => {
  return new Proxy(obj, {
    get(target, prop) {
      if (privateProps.includes(prop)) {
        throw new Error(`Cannot access private property ${prop}`);
      }
      return Reflect.get(target, prop);
    },
    set(target, prop, value) {
      if (privateProps.includes(prop)) {
        throw new Error(`Cannot set private property ${prop}`);
      }
      return Reflect.set(target, prop, value);
    }
  });
};

const obj = createPrivatePropsObject({ 
  public: 1, 
  _secret: 2 
}, ['_secret']);

console.log(obj.public); // 1
console.log(obj._secret); // Error: Cannot access private property _secret
```

### 3. 实现函数参数验证
```javascript
const validateArgs = (func, validator) => {
  return new Proxy(func, {
    apply(target, thisArg, args) {
      if (!validator(...args)) {
        throw new Error('Invalid arguments');
      }
      return Reflect.apply(target, thisArg, args);
    }
  });
};

const sum = validateArgs((a, b) => a + b, (a, b) => {
  return typeof a === 'number' && typeof b === 'number';
});

sum(1, 2); // 3
sum('1', 2); // Error: Invalid arguments
```

## 四、常见陷阱与注意事项

1. **Proxy 的透明性**：
   - `typeof proxy` 返回 `"object"`
   - `proxy instanceof TargetClass` 与目标对象行为一致
   - 但 `Object.prototype.toString.call(proxy)` 返回 `[object Object]`

2. **可撤销 Proxy**：
   ```javascript
   const { proxy, revoke } = Proxy.revocable(target, handler);
   revoke(); // 之后所有对 proxy 的操作都会抛出 TypeError
   ```

3. **性能考虑**：
   - Proxy 会带来一定的性能开销
   - 不适合在性能关键路径上大量使用
   - V8 等现代引擎已对 Proxy 做了优化

4. **无法拦截的操作**：
   - 严格相等比较（`===`）
   - `Object.keys()` 等操作只能部分拦截

## 五、面试进阶问题

### 1. 如何用 Proxy 实现简单的 Vue 响应式系统？
**要点**：
- 使用 Proxy 拦截数据访问和修改
- 建立依赖收集机制
- 实现 computed 和 watch

### 2. Proxy 相比 Object.defineProperty 有什么优势？
**答案**：
- 可以拦截更多操作（如 `in`、`delete`、方法调用等）
- 直接代理整个对象，不需要遍历属性
- 性能更好（特别是对大型对象）
- 可以代理数组，完美支持数组方法

### 3. 如何用 Proxy 实现不可变数据结构？
**思路**：
- 拦截所有修改操作
- 返回新对象而不是修改原对象
- 结合结构共享优化性能

### 4. Reflect 为什么设计为静态类而不是实例方法？
**原因**：
- 保持 API 的纯粹性和一致性
- 避免与现有对象方法冲突
- 更符合元编程的定位
- 便于未来扩展

掌握 Proxy 和 Reflect 不仅能帮助应对面试，更能提升日常开发中对 JavaScript 元编程能力的运用水平。建议结合实际项目经验理解这些概念，并准备相关实战案例。


10. webpack 与 vite

- 如何优化构建速度
分析：webpack-bundle-analyzer、rollup-plugin-visualizer
方案：换打包工具、拆分第三方包、使用 cdn

如何通过 `DLLPlugin` 和持久化缓存提升京东首页构建速度？

将那些不常变动的、体积较大的依赖（例如 React、Vue、lodash 等）预先打包成一个或多个 DLL（动态链接库）文件。当主应用进行构建时，webpack 不再需要重新处理这些 DLL 文件，而是直接引用它们，从而大大减少了主应用的构建时间。

创建 webpack.dll.config.js
entry: {
        // 将常用的库单独打包
        vendor: ['react', 'react-dom', 'lodash', 'axios']
    },

主配置中，webpack.DllReferencePlugin 引入生成的manifest文件、AddAssetHtmlPlugin 将ddl注入html

持久化缓存（Persistent Caching）是 webpack 5 引入的一项重要功能，它会将构建结果（包括模块、loaders 等）缓存到磁盘上
cache: {
        type: 'filesystem', // 启用文件系统缓存
        buildDependencies: {
            // 缓存的 key，当配置文件或 package.json 发生变化时，缓存会失效
            config: [__filename]
        }
    }



vite 为什么会快
主要源于其创新的原生ES模块(ESM)利用和预构建优化架构设计

技术点	Webpack	Vite
编译工具	Babel + Terser	esbuild（Go语言编写，快10-100x）
HMR(热更新)	全量重建依赖图	基于ESM的精准边界HMR
TS处理	需配置ts-loader	原生支持.ts文件
CSS处理	需css-loader	原生支持import './style.css'
启动机制	打包后启动	直接启动+按需编译


11. 如何量化首屏性能（LCP、FID、CLS）

FCP
- PerformanceObserver --> entry.name === 'first-contentful-paint' --> entry.startTime

LCP
- PerformanceObserver 或第三方库 web-vitals --> lastEntry.renderTime || lastEntry.loadTime --> LCP
优化关键资源加载（CSS、JS、字体）
使用预加载（<link rel="preload">）
消除渲染阻塞资源
优化服务器响应时间（TTFB）

FID
- entry.processingStart - entry.startTime
减少主线程工作（分解长任务）
优化JavaScript执行（代码分割、懒加载）
最小化第三方脚本影响
使用 Web Worker 处理复杂计算

累计布局偏移 CLS
- !entry.hadRecentInput 时累加 entry.value;
为图片和视频设置尺寸属性（width/height）
避免在现有内容上方插入动态内容
使用 transform 动画代替影响布局的属性
预加载重要资源

> 如何做预加载、预链接：
preload：
不执行资源，只是提前缓存，优先级高
必须指定 as 属性（style/script/font/image等）
字体文件需要加 crossorigin 属性

prefetch：
空闲时加载后续可能需要的资源（优先级较低

preconnect：
提前建立TCP连接、TLS协商（比dns-prefetch更全面）
用于提前加载字体、CDN、链接API服务器、或者广告分析服务等。
可以和 preload配合使用

> navigator.sendBeacon('/analytics', analyticsData); 资源上报<64kb, 不延迟页面加载


12. 父子组建通信有几种方式

Props（父传子）
Events（子传父）
ref（父访问子实例）
自定义 Event （双向）
WebAPI，例如 MessageChannel （双向）

13. 长列表渲染优化（虚拟滚动、IntersectionObserver） 

https://juejin.cn/post/7134997708598673439

14. 如何设计前端埋点系统？（数据上报策略、降级方案）

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  数据采集层   │───▶│  数据处理层   │───▶│  数据存储层   │
└─────────────┘    └─────────────┘    └─────────────┘
       ▲                    │                    │
       │                    ▼                    ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   客户端      │    │  实时计算    │    │  离线分析    │
└─────────────┘    └─────────────┘    └─────────────┘
```
关键行为：navigator.sendBeacon
批量高频操作：batchQueue=[]; 定时通过fetch往后台推送队列消息
也可以采样上报（随机抽样、分类抽样等）

降级方案：
- 优先使用sendBeacon
- 次选fetch + keepalive
- 最差情况使用Image打点

IndexedDB >  localStorage > memoryStore=[]

网络状态上报：
navigator.connection --> rtt 往返延时
> navigator 属性 clipboard，languages等

15. 重排（Reflow）与重绘（Repaint）的优化策略  

重排：

添加/删除可见DOM元素
元素位置、尺寸变化（包括边距、填充、边框等）
内容变化（如文本改变或图片大小改变）
页面渲染初始化
浏览器窗口尺寸改变
读取某些属性（如offsetTop、scrollHeight等）

> 优化：批量dom操作和样式classList使用、文档片段等

重绘

颜色、背景色、透明度等样式变化
边框样式变化
阴影变化
visibility变化（但不影响布局）

> 优化：使用transform和opacity、will-change、避免在循环里读取-写入样式、使用精准的css选择器 div > span
> will-change 提前告知浏览器元素可能发生的变化。用于即将发生的复杂动画或交互。常用于 transform、opacity或scroll-position。会增加GPU内存占用，不要使用 all 等。

16. `requestAnimationFrame` vs. `setTimeout` 在动画渲染中的区别 

特性	requestAnimationFrame	   setTimeout
设计初衷	专为动画渲染优化	     通用的延迟执行机制
调用时机	在下一次浏览器重绘前执行	    在指定延迟时间后执行（不考虑渲染周期）
执行频率	与屏幕刷新率同步（通常60fps，约16.7ms/帧）  	严格按设定时间间隔执行
自动暂停	页面隐藏时自动停止（节省资源）  	持续执行（即使页面不可见）
回调参数	提供高精度时间戳（performance.now()）  	无时间戳参数

> document.documentElement.animate 怎么用  startViewTransition.ready.then + ::view-transition-old(root)

17. performance

Performance API 提供高精度的时间测量和性能指标获取能力
performance.getEntriesByType 获取对应指标，比如 paint
performance.now() 微秒级精度，单调递增（不受系统时间调整影响），返回一个从页面导航开始计算的时间戳（单位毫秒）


18. HTTP/2 多路复用与头部压缩（HPACK）

二进制分帧层，将消息分解为独立的帧（Frame），每个请求/响应对应一个流（ID唯一）

场景	HTTP/1.1	HTTP/2
100个小型资源	6连接×16请求=96	1连接×100请求
延迟时间	高（RTT×连接数）	低（1-2个RTT）
TCP连接利用率	20-30%	90%+

---
HPACK： HTTP/1.x 中，头部字段信息比较多，多次请求或响应重复携带，导致不必要的带宽浪费和延迟增加。
预制一个静态索引表，直接发送索引编号
还有一个动态表，存储一下最近一次发送的头部
特殊情况字面值编码（霍夫曼编码：根据出现的频率构造霍夫曼树）


19. HTTPS 握手过程（TLS 1.3 优化点） 



20. HTTP 长连接、SSE 与 WebSocket 对比

| 特性                | HTTP 长连接          | SSE                  | WebSocket            |
|---------------------|---------------------|----------------------|----------------------|
| **通信方向**         | 客户端→服务器        | 服务器→客户端        | 全双工通信               |
| **协议基础**         | HTTP                | HTTP                 | 独立协议             |
| **连接建立**         | HTTP 握手           | HTTP 握手            | HTTP 升级握手        |
| **数据格式**         | 任意 HTTP 格式      | `text/event-stream`  | 二进制/文本          |
| **头部开销**         | 每次请求都有头部    | 首次连接后无头部     | 握手后无头部         |
| **自动重连**         | 不支持              | 支持                 | 需手动实现           |
| **浏览器支持**       | 所有浏览器          | 除 IE 外的主流浏览器 | IE10+ 和现代浏览器   |
| **服务器推送**       | 不支持              | 支持                 | 支持                 |
| **适用场景**         | 资源加载/API调用    | 服务器通知           | 实时交互应用         |

21. 高并发降级策略

关闭一些非核心功能，释放资源给核心功能（可以配置或代码判断）
数据降级：减少数据的复杂度或精度，以降低处理成本。
服务降级：备用接口和数据缓存
依赖服务熔断机制：超过阈值直接熔断（Hystrix）
边缘计算: CDN 等更靠近用户终端的服务

22. 手写快速排序（递归与非递归实现）  

```js
function quicksort(arr) {
   if(arr.length < 2){
        return arr
    }else{
        let pivot = arr[0];
        let less = arr.slice(1).filter(function(value,index){
            return value <= pivot;
        })
        let greater = arr.slice(1).filter(function(value,index){
            return value > pivot;
        })

        return [...quicksort(less), pivot, ...quicksort(greater)]; 
    }
}
```

```js
function partition(arr, low, high) {
  const pivot = arr[high]; // 选择最后一个元素作为基准
  let i = low; // i是小于基准的元素的边界

  for (let j = low; j < high; j++) {
    if (arr[j] < pivot) {
      [arr[i], arr[j]] = [arr[j], arr[i]]; // 交换元素
      i++;
    }
  }
  
  [arr[i], arr[high]] = [arr[high], arr[i]]; // 将基准放到正确位置
  return i; // 返回基准索引
}

function quickSortIterativeOpt(arr) {
  const stack = [];
  let low = 0;
  let high = arr.length - 1;
  
  stack.push(low);
  stack.push(high);

  while (stack.length > 0) {
    high = stack.pop();
    low = stack.pop();
    
    const pivotIndex = partition(arr, low, high);
    
    // 先处理较小的子数组，减少栈深度
    if (pivotIndex - low < high - pivotIndex) {
      if (pivotIndex + 1 < high) {
        stack.push(pivotIndex + 1);
        stack.push(high);
      }
      if (low < pivotIndex - 1) {
        stack.push(low);
        stack.push(pivotIndex - 1);
      }
    } else {
      if (low < pivotIndex - 1) {
        stack.push(low);
        stack.push(pivotIndex - 1);
      }
      if (pivotIndex + 1 < high) {
        stack.push(pivotIndex + 1);
        stack.push(high);
      }
    }
  }
  return arr;
}
```

23. 手写二叉树遍历

层次遍历：

```js
function traverse(node) {
	if (!node) { 
		return;

	}

	const queue = [];
	queue.unshift(node);

	while(queue.length > 0) {
		const printNode = queue.pop();
		console.log(printNode.name)
		if(printNode.children && printNode.children.length > 0) {
			queue.unshift(...(printNode.children.reverse()));
		}
	}
}
```

先序：

```js
function traverse(node) {
	if (!node) return;
	
	// 前序遍历
	const track = [];
	track.push(node);
	
	while (track.length > 0) {
		const node = track.pop();
		console.log(node.name);
		const children = node.children;
		if (children && children.length > 0) {
			track.push(...children.reverse());
		}
	}
}
```

后序:

```js
function traverse(node) {
	if (!node) return;
	
	// 后序遍历(先序遍历的逆向)
	const track = [];
	const quene = [];
	track.push(node);
	
	while (track.length > 0) {
		const node = track.pop();
		quene.push(node.name);
		const children = node.children;
		if (children && children.length > 0) {
			track.push(...children);
		}
	}
	
	return quene.reverse();
}
```
中序：
```js
function traverse(node) {
	if (!node) return;
	
	// 中序遍历
	const stack = [];
	let currentNode = node;
	while (currentNode || (stack.length > 0)) {
		if (currentNode) {
			stack.push(currentNode);
			currentNode = (currentNode && currentNode.children) ? currentNode.children[0] : null;
		} else {
			const poped = stack.pop();
			console.log(poped.name);
			currentNode = poped.children ? poped.children[1] : null;
		}
	}
	
}
```

24. 重复单词统计

```js
var arr = ["apple","orange","apple","orange","pear","orange"];
function getWordCnt(){
    //以下应掏空
    return arr.reduce(function(prev,next,index,arr){
        prev[next] = (prev[next] + 1) || 1; //这句是重点,刚开始都是undefined的时候undefined+1会是NaN
        return prev;
    },{});
}
```

25. 哈希表的实现原理（冲突解决策略） 

哈希表的核心思想是通过哈希函数将键映射到一个固定大小的数组（即哈希表）中的某个位置。然而，由于哈希函数的输出范围有限（通常小于键的总数），因此不可避免地会出现多个键映射到同一个位置的情况，这就是冲突（Collision）。


26. 前端开发流程

https://juejin.cn/post/7085257325165936648

27. 浏览器兼容性 

antv x6 的 foreignObject 的 safari 下兼容

28. 性能优化

  - 京东首页如何通过 **静态化+CDN边缘缓存** 将首屏控制在 `1.2s` 内？  
  - 图片加载策略：`WebP` 自适应 + 懒加载（或渐进式jpg） + 本地 `localStorage` 缓存 （base64） 

29. 如何通过 `Sentry` 实现前端错误的全链路追踪？  

window.onerror 全局监听： Sentry.captureException(error || message);
unhandledrejection 事件
重写 fetch：
```js

const originalFetch = window.fetch;
window.fetch = async function(...args) {
  const transaction = Sentry.startTransaction({ name: `fetch ${args[0]}` });
  try {
    const response = await originalFetch.apply(this, args);
    transaction.finish();
    return response;
  } catch (err) {
    Sentry.captureException(err);
    transaction.finish();
    throw err;
  }
};
```
Console 方法劫持

获取客户端信息
navigator.userAgent（设备/浏览器信息）
window.location（当前 URL）
document.referrer（来源页面）

架构方面：

