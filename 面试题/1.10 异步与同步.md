## 1. 浏览器渲染原理

https://juejin.cn/post/7293820517375623168

## 2. RxJS 基本使用

https://juejin.cn/post/7110879353109970958

## 3. 下面输出什么

```js
Promise.resolve().then(() => {
    console.log(1)
}).catch(() => {
    console.log(2)
}).then(() => {
    console.log(3)
})
// 1 3


async function async1() {
  console.log('a');
  await async2(); // 这一句会同步执行，返回 Promise ，其中的 `console.log('c')` 也会同步执行
  console.log('b'); // 上面有 await ，下面就变成了“异步”，类似 cakkback 的功能（微任务）
}

async function async2() {
  console.log('c')
}

console.log('d')
async1();

setTimeout(()=> {
  console.log('e')
},0)

new Promise((resolve, reject) => {
  console.log('f') // 这里是同步代码
  resolve()
}).then(()=> { // catch 和 finally 都是和 then 一样的微循环
  console.log('g')
}) 

// 1. d
// 2. a
// 3. c
// 4. f
// 5. b
// 6. g
// 7. e

Promise.resolve().then(() => {
    console.log(1)
    throw new Error('erro1')
}).catch(() => {
    console.log(2)
}).then(() => {
    console.log(3)
})
// 1 2 3
```

## 4. 手写符合Promises/A+规范的Promise

```js
class MyPromise {
  constructor(executor) {
    this.state = 'pending'; // 状态：pending, fulfilled, rejected
    this.value = undefined; // 成功值
    this.reason = undefined; // 失败原因
    this.onFulfilledCallbacks = []; // 成功回调队列
    this.onRejectedCallbacks = []; // 失败回调队列

    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        // 异步执行所有成功回调
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    };

    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        // 异步执行所有失败回调
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };

    try {
      // 立即执行执行器函数
      executor(resolve, reject);
    } catch (err) {
      // 捕获同步错误
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    // 处理值穿透（then的参数不是函数时，透传value/reason）
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };

    const promise2 = new MyPromise((resolve, reject) => {
      const handleFulfilled = () => {
        queueMicrotask(() => { // 模拟微任务
          try {
            const x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        });
      };

      const handleRejected = () => {
        queueMicrotask(() => {
          try {
            const x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        });
      };

      if (this.state === 'fulfilled') {
        handleFulfilled();
      } else if (this.state === 'rejected') {
        handleRejected();
      } else { // pending状态时存入队列
        this.onFulfilledCallbacks.push(handleFulfilled);
        this.onRejectedCallbacks.push(handleRejected);
      }
    });

    return promise2; // 实现链式调用
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }
}

// 处理thenable对象和递归（Promise/A+ 规范2.3）
function resolvePromise(promise2, x, resolve, reject) {
  if (promise2 === x) {
    return reject(new TypeError('Chaining cycle detected'));
  }

  if (x instanceof MyPromise) {
    x.then(resolve, reject);
  } else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    let then;
    try {
      then = x.then;
    } catch (err) {
      return reject(err);
    }

    if (typeof then === 'function') {
      let called = false;
      try {
        then.call(
          x,
          y => {
            if (!called) {
              called = true;
              resolvePromise(promise2, y, resolve, reject);
            }
          },
          r => {
            if (!called) {
              called = true;
              reject(r);
            }
          }
        );
      } catch (err) {
        if (!called) reject(err);
      }
    } else {
      resolve(x);
    }
  } else {
    resolve(x);
  }
}

// 测试用例
new MyPromise((resolve) => {
  setTimeout(() => resolve(1), 1000);
})
  .then(res => {
    console.log(res); // 1
    return res + 1;
  })
  .then(res => {
    console.log(res); // 2
    return new MyPromise(resolve => resolve(res + 1));
  })
  .then(console.log); // 3
```

面试简单版：

```js
function myPromise(constructor){ let self=this;
  self.status="pending" //定义状态改变前的初始状态 
  self.value=undefined;//定义状态为resolved的时候的状态 
  self.reason=undefined;//定义状态为rejected的时候的状态 
  function resolve(value){
    //两个==="pending"，保证了了状态的改变是不不可逆的 
    if(self.status==="pending"){
      self.value=value;
      self.status="resolved"; 
    }
  }
  function reject(reason){
     //两个==="pending"，保证了了状态的改变是不不可逆的
     if(self.status==="pending"){
        self.reason=reason;
        self.status="rejected"; 
      }
  }
  //捕获构造异常 
  try{
      constructor(resolve,reject);
  }catch(e){
    reject(e);
    } 
}
myPromise.prototype.then = function(onFullfilled,onRejected){ 
  let self=this;
  switch(self.status){
    case "resolved": onFullfilled(self.value); break;
    case "rejected": onRejected(self.reason); break;
    default: 
  }
}
```

## 5. 如何实现一个带超时功能的Promise.all？

```js
/**
 * 带超时的Promise.all
 * @param promises Promise数组
 * @param timeout 超时时间(ms)
 * @returns 结果数组或超时错误
 */
function promiseAllWithTimeout<T>(
  promises: Promise<T>[],
  timeout: number
): Promise<T[]> {
  // 1. 为每个原始Promise添加超时控制
  const timeoutPromises = promises.map(promise => 
    new Promise<T>((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error(`Promise timed out after ${timeout}ms`));
      }, timeout);

      promise
        .then(resolve)
        .catch(reject)
        .finally(() => clearTimeout(timer)); // 清理定时器
    })
  );

  // 2. 用Promise.all包裹超时控制后的Promises
  return Promise.all(timeoutPromises);
}
```

## 6. 并发请求限制（如限制5个并行）

#### 使用队列和递归: 
- 维护一个执行中的Promise集合（executing）
- 使用递归方式逐个添加请求
- 当执行中的请求数达到限制时，等待其中一个完成后再继续

#### Promise.race动态控制
- 遍历所有请求URL
- 为每个请求创建Promise并加入执行集合
- 当执行集合大小达到限制时，使用Promise.race等待最快的请求完成
- 从执行集合中移除已完成的请求，继续添加新请求

```js
async function limitRequests(urls, limit = 5) {
  const results = [];
  const executing = new Set();
  
  for (let i = 0; i < urls.length; i++) {
    const url = urls[i];
    const promise = fetch(url)
      .then(res => res.json())
      .then(res => {
        results[i] = res; // 按索引存储保持顺序
        return i; // 返回索引用于跟踪
      });
    
    executing.add(promise);
    
    if (executing.size >= limit) {
      const completedIndex = await Promise.race(executing);
      executing.delete(completedIndex);
    }
  }
  
  await Promise.all(executing); // 等待剩余请求完成
  return results;
}
```

#### Semaphore信号量模式
#### async-pool风格实现
- 结合Promise.race和Promise.all
- 维护执行中的Promise集合
- 当集合达到限制时，等待任意一个完成
- 使用Promise.all等待所有请求完成

```js
async function asyncPool(poolLimit, array, iteratorFn) {
  const ret = []; // 存储所有Promise
  const executing = new Set(); // 执行中的Promise
  
  for (const item of array) {
    const p = Promise.resolve().then(() => iteratorFn(item));
    ret.push(p);
    executing.add(p);
    
    const clean = () => executing.delete(p);
    p.then(clean).catch(clean);
    
    if (executing.size >= poolLimit) {
      await Promise.race(executing);
    }
  }
  
  return Promise.all(ret);
}

// 使用示例
async function limitRequests(urls, limit = 5) {
  return asyncPool(limit, urls, url => 
    fetch(url).then(res => res.json())
  );
}
```

## 7. 手写Promise.all

```js
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    // 边界情况：如果输入不是数组，直接resolve
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Arguments must be an array'));
    }

    const results = []; // 存储结果
    let completedCount = 0; // 完成的Promise计数

    // 处理空数组情况
    if (promises.length === 0) {
      return resolve(results);
    }

    promises.forEach((promise, index) => {
      // 确保每个元素都是Promise，如果不是则用Promise.resolve包装
      Promise.resolve(promise)
        .then(result => {
          results[index] = result; // 按顺序保存结果
          completedCount++;
          
          // 当所有Promise都完成时resolve结果数组
          if (completedCount === promises.length) {
            resolve(results);
          }
        })
        .catch(err => {
          // 任何一个Promise失败就立即reject
          reject(err);
        });
    });
  });
}
```

## 8. Web Worker基本使用与通信优化

## 9. Vue的nextTick实现原理
## 10. React useEffect 的清理时机

| 特性                | Vue nextTick                  | React useEffect清理           |
|---------------------|-------------------------------|-------------------------------|
| **触发时机**        | 下次DOM更新循环结束后         | 组件卸载或依赖变更前          |
| **任务类型**        | 微任务                        | 同步执行                      |
| **主要用途**        | 获取更新后DOM状态             | 取消订阅/清理副作用           |
| **批量处理**        | 自动合并同Tick调用            | 依赖变更时才会重新执行        |
| **底层实现**        | 微任务队列                    | Fiber架构的effect链表         |
| **典型场景**        | 操作更新后的DOM               | 取消网络请求/移除事件监听     |


## 11. 浏览器如何实现微任务优先机制？

优先级规则
- 每执行完一个宏任务后：立即清空整个微任务队列
- 微任务执行期间新产生的微任务：会追加到当前队列并继续执行，直到队列为空

```cpp
// 简化的V8微任务队列处理逻辑（C++）
class MicrotaskQueue {
  std::queue<Microtask> queue;
  
  void Enqueue(Microtask task) {
    queue.push(task);
  }

  void PerformCheckpoint() {
    while (!queue.empty()) {
      Microtask task = queue.front();
      queue.pop();
      task.Run(); // 执行微任务
    }
  }
};
```

## 12. Promise 优缺点

#### Promise优点

①统一异步 API

Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法

②Promise 与事件对比

和事件相比较， Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。 Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。

③Promise 与回调对比

解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。

④Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如 Array.prototype.map() ）。

#### Promise缺点

1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。

2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。

3、当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

4、Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。

## 小测验

```js
// 输出啥，放浏览器里跑一跑，看和你想的一样吗
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
console.log("js start");
setTimeout(function () {
  console.log("timeout");
}, 0);
async1();
new Promise(function (resolve) {
  console.log("promise");
  resolve();
}).then(function () {
  console.log("then");
});
console.log("js end");
```