# BOM

## 1. BOM 是什么？如何操作窗口？

BOM 是浏览器对象模型，提供了与浏览器窗口交互的接口。

```js
// 打开新窗口 (safari 可打开 '' 的URL，然后 window.location.href 重新赋值)
const newWindow = window.open('https://example.com', '_blank', 'width=400,height=300');

// 关闭当前窗口
window.close();

// 调整窗口大小
window.resizeTo(800, 600);
window.resizeBy(100, 100); // 相对调整

// 移动窗口位置
window.moveTo(100, 100);
window.moveBy(50, 50); // 相对移动
```

## 2. 跨浏览器窗口通信

```js
// 父窗口
const child = window.open('child.html');
child.postMessage('Hello from parent', 'https://child-origin.com');

// 子窗口接收
window.addEventListener('message', (event) => {
  if (event.origin !== 'https://parent-origin.com') return;
  console.log('Received:', event.data);
});
```
也可以使用 BroadcastChannel 进行跨窗口通信

## 3. 不刷新页面的情况下如何修改 URL？

```js
// 修改整个URL
window.location.assign('https://new-url.com');
window.location.href = 'https://new-url.com';

// 修改部分URL
location.search = '?page=2'; // 查询参数
location.hash = '#section';  // 哈希值

// 替换当前历史记录
location.replace('https://new-url.com'); 

// 仅修改pathname
location.pathname = '/new-path';
```

## 4. 如何实现前端路由的跳转而不刷新页面？

```js
// 添加历史记录
history.pushState({page: 1}, 'Title 1', '/page1');

// 替换当前历史记录
history.replaceState({page: 2}, 'Title 2', '/page2');

// 监听popstate事件
window.addEventListener('popstate', (event) => {
  console.log('State:', event.state);
});
```

## 5. 如何检测用户的浏览器和设备信息？

```js
// 浏览器信息
const isChrome = /Chrome/.test(navigator.userAgent);
const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);

// 更现代的API
const isOnline = navigator.onLine;
const batteryPromise = navigator.getBattery();
const memory = navigator.deviceMemory; // 内存大小(GB)

// 地理位置
navigator.geolocation.getCurrentPosition(success, error);
```

## 6. 如何获取用户的屏幕信息？ Screen对象
## 7. setTimeout 和 requestAnimationFrame 有什么区别？如何实现精确计时？

| 特性 | setTimeout | requestAnimationFrame |
|------|------------|-----------------------|
| **执行时机** | 延迟指定毫秒后将回调加入任务队列，等待主线程空闲执行 | 浏览器下一次重绘前执行（通常与显示器刷新率同步，约16.7ms/帧） |
| **时间精度** | 受任务队列阻塞影响，实际延迟 ≥ 指定时间，最小延时大约4ms | 与浏览器重绘周期对齐，时间精度更高（±1ms） |
| **用途场景** | 通用定时任务（非动画场景） | 视觉动画渲染（如DOM动画、Canvas绘制） |
| **后台行为** | 标签页后台仍会执行（但延迟增加到1000ms+） | 标签页后台时会暂停执行，节省CPU资源 |
| **调用频率** | 需手动控制调用间隔 | 浏览器自动控制（通常60次/秒） |

```js
// 高精度计时
const start = performance.now();
// 执行代码
const duration = performance.now() - start;
```

## 8. 如何监听页面的可见性变化和生命周期状态？

```js
// 页面可见性
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    // 页面可见
  } else {
    // 页面隐藏
  }
});

// 页面生命周期
window.addEventListener('load', () => {});
window.addEventListener('DOMContentLoaded', () => {});
window.addEventListener('beforeunload', (event) => {
  event.preventDefault();
  event.returnValue = ''; // 某些浏览器需要
});
```

## 9. 如何实现前端性能监控和数据上报？

```js

// 关键性能指标
const timing = performance.timing;
const loadTime = timing.loadEventEnd - timing.navigationStart;

// 资源加载监控
const resources = performance.getEntriesByType('resource');

// 内存监控
window.performance.memory; // Chrome only

// 错误监控
window.addEventListener('error', (event) => {
  // 上报错误
});
```

## 10. 如何准确统计用户在页面的停留时间？

```js
let startTime = Date.now();
let activeTime = 0;
let lastActiveTime = startTime;

document.addEventListener('mousemove', updateActiveTime);
document.addEventListener('keypress', updateActiveTime);

function updateActiveTime() {
  const now = Date.now();
  activeTime += now - lastActiveTime;
  lastActiveTime = now;
}

window.addEventListener('beforeunload', () => {
  updateActiveTime();
  const totalTime = Date.now() - startTime;
  console.log(`总时间: ${totalTime}ms, 活跃时间: ${activeTime}ms`);
  // 发送统计数据
});
```

## 11. 如何使用BOM API实现文件拖拽上传功能？

```js
const dropArea = document.getElementById('drop-area');

dropArea.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropArea.classList.add('dragover');
});

dropArea.addEventListener('dragleave', () => {
  dropArea.classList.remove('dragover');
});

dropArea.addEventListener('drop', (e) => {
  e.preventDefault();
  dropArea.classList.remove('dragover');
  
  const files = e.dataTransfer.files;
  if (files.length) {
    handleFiles(files);
  }
});

function handleFiles(files) {
  const formData = new FormData();
  formData.append('file', files[0]);
  
  fetch('/upload', {
    method: 'POST',
    body: formData
  });
}
```

# DOM

## 1. 对比 innerHTML 和 createElement 的性能差异，何时使用哪种方式？
## 2. 如何用事件委托实现一个无限滚动列表的点击处理？

```js
document.getElementById('list').addEventListener('click', function(e) {
  if (e.target.classList.contains('item')) {
    console.log('点击的项目ID:', e.target.dataset.id);
  }
  
  // 加载更多检测
  if (e.target.classList.contains('load-more')) {
    fetchMoreData();
  }
});
```

## 3. 如何创建并触发一个自定义事件？

```js
// 创建自定义事件
const event = new CustomEvent('myEvent', {
  detail: { message: '自定义数据' },
  bubbles: true,
  cancelable: true
});

// 监听事件
element.addEventListener('myEvent', (e) => {
  console.log(e.detail.message);
});

// 触发事件
element.dispatchEvent(event);
```

## 4. 事件循环

https://juejin.cn/post/7288956366515929088

## 5. 浏览器渲染原理

https://juejin.cn/post/7293820517375623168

## 6. 哪些DOM操作会导致重排(Reflow)？如何优化？

- 几何属性修改
- DOM结构操作
- 布局信息读取，例如 getBoundingClientRect
- 浏览器窗口操作

优化：

- 批量DOM操作
- 使用文档碎片：createDocumentFragment
- 脱离文档流操作
- 避免布局抖动，比如循环里反复读取位置信息
- CSS优化，比如使用 transform 代替 top/left
- 硬件加速，比如使用 will-change 属性

## 7. 如何使用MutationObserver监听DOM变化？

```js
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    if (mutation.type === 'childList') {
      console.log('子节点变化');
    } else if (mutation.type === 'attributes') {
      console.log('属性变化:', mutation.attributeName);
    }
  });
});

observer.observe(document.getElementById('target'), {
  attributes: true,
  childList: true,
  subtree: true
});

// 停止观察
observer.disconnect();
```

## 8. 如何实现一个带验证和自动保存的表单？

```js
class FormManager {
  constructor(formId) {
    this.form = document.getElementById(formId);
    this.init();
  }
  
  init() {
    // 输入验证
    this.form.addEventListener('input', debounce(this.validate.bind(this), 300));
    
    // 自动保存
    this.form.addEventListener('input', debounce(this.autoSave.bind(this), 2000));
  }
  
  validate() {
    // HTML5验证API
    if (!this.form.checkValidity()) {
      // 显示错误信息
    }
  }
  
  autoSave() {
    const formData = new FormData(this.form);
    fetch('/save', { method: 'POST', body: formData });
  }
}
```

## 9. 如何优化渲染包含10万条数据的列表？

https://juejin.cn/post/7134997708598673439

## 10. 如何使用Shadow DOM实现组件封装？

```js
class MyComponent extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: 'open' });
    
    const style = document.createElement('style');
    style.textContent = `
      .container { padding: 20px; }
    `;
    
    const container = document.createElement('div');
    container.className = 'container';
    container.textContent = 'Shadow DOM内容';
    
    shadow.appendChild(style);
    shadow.appendChild(container);
  }
}

customElements.define('my-component', MyComponent);
```

## 11. getBoundingClientRect() 与 offsetTop/offsetLeft 有什么区别？

getBoundingClientRect 返回的DOMRect对象包含以下属性（相对于视口）：
- x/y: 元素左上角相对于视口的X/Y坐标（等价于left/top）
- left/top: 元素左上角相对于视口的左/上偏移
- right/bottom: 元素右下角相对于视口的右/下偏移
- width/height: 元素的布局宽度/高度（包含padding和border）

| 特性	| getBoundingClientRect()	| offsetTop/offsetLeft| 
| --| --| -- | 
坐标系| 	相对于视口(viewport)	| 相对于offsetParent| 
包含滚动距离| 	否	| 是| 
返回值类型| 	浮点数(含小数)| 	整数(四舍五入)| 
触发重排	| 是	| 是| 
包含transform| 	计算变换后的位置| 	忽略CSS transform| 

## 12. 如何实现元素在视口中的居中显示？

```js
function centerElement(el) {
  const rect = el.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  
  el.style.position = 'fixed';
  el.style.left = `${(viewportWidth - rect.width) / 2}px`;
  el.style.top = `${(viewportHeight - rect.height) / 2}px`;
  
  // 考虑滚动条的影响 (这会造成半个像素的模糊问题)
  el.style.transform = 'translate(-50%, -50%)';
}
```

## 13. 如何检测元素是否完全进入视口？

- IntersectionObserver
- scroll 事件 + 检测函数
```js
function isPartiallyInViewport(el, threshold = 0.5) {
  const rect = el.getBoundingClientRect();
  const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
  const visibleWidth = Math.min(rect.right, window.innerWidth) - Math.max(rect.left, 0);
  return (visibleHeight * visibleWidth) >= (rect.width * rect.height * threshold);
}
```

## 14. 频繁调用 getBoundingClientRect() 会导致什么性能问题？如何优化？

每次调用都会强制同步布局（layout thrashing）

- 优化方案1：批量读取（FastDOM模式）
- 使用IntersectionObserver（现代浏览器）

## 15. 如何实现高精度的元素尺寸监听？

使用 ResizeObserver，在不兼容的浏览器可写 ResizeObserverPolyfill。

## 16. getBoundingClientRect() 在浏览器渲染流水线中的哪个阶段执行？为什么它会强制触发布局？

发生在 Layout 阶段之后，需要读取布局信息。它会中断浏览器的优化管道，强制同步执行布局计算。

一般的，浏览器通常会批量处理样式变更（异步布局），当代码请求布局信息（如getBoundingClientRect）时，浏览器必须立即计算最新布局以保证数据准确

## 17. translate(-50%, -50%) 导致的半个像素模糊问题

模糊原因：

- 子像素渲染问题：当元素被定位到半个像素位置时（如 left: 50.5px），浏览器无法精确渲染半个物理像素
- 抗锯齿处理：浏览器会尝试通过抗锯齿技术来平滑边缘，导致视觉上的模糊效果
- GPU加速影响：某些浏览器的GPU加速渲染对子像素位置的处理方式不同

解决方案：

- 1. translateZ(0)， 可以触发GPU加速，浏览器会倾向于将元素对齐到完整整数像素
- 2. 强制宽高是偶数
- 3. JavaScript 精确计算
- 4. Flexbox 替代方案
- 5. css Round()

## 18. 什么是 DocumentFragment？

- 轻量级的文档节点容器
- 不属于主 DOM 树，存在于内存中
- 批量操作 DOM 时作为临时容器使用

## 19. 如何用 DocumentFragment 实现模板引擎？

```js
class TemplateEngine {
  constructor(template) {
    this.fragment = document.createDocumentFragment();
    const temp = document.createElement('div');
    temp.innerHTML = template;
    while (temp.firstChild) {
      // 当调用 appendChild 移动一个已存在的节点时，它会自动从原父节点移除该节点。
      this.fragment.appendChild(temp.firstChild);
    }
  }
  
  render(data) {
    const clone = this.fragment.cloneNode(true);
    this._process(clone, data);
    return clone;
  }
  
  _process(node, data) {
    // 处理数据绑定逻辑
    // ...
  }
}

// 使用
const template = '<div>{{name}}</div>';
const engine = new TemplateEngine(template);
const rendered = engine.render({ name: '张三' });
document.body.appendChild(rendered);
```

## 20. 如何用 DocumentFragment 实现虚拟滚动？

